#!/bin/sh -Cue
#.help
# % CMD..
#
# For each input line, run "CMD.. LINE" under a jobserver, which is created if required.
#
# Note: a partial final line (eg. at unexpected EOF) is not detected.
#
# Options:
# -a  --verbatim              --blanks --comments --no-strip
# -b  --blanks                don't ignore blank lines
# -c  --comments              don't ignore lines matching /^ *#/
#     --no-strip              don't strip leading/trailing spaces
#
#     --no-blanks             ignore blank lines (default)
#     --no-comments           ignore lines matching /^ *#/ (default)
#     --strip                 strip leading and trailing spaces (default)
#
# Environment exported to CMD:
#     JOBNO                   job number, increment for non-ignored lines
#     LINENO                  input line number, increment for all lines
#     ORIG_LINE               original line

if jobsv_sh="$(which jobsv.sh 2>/dev/null)"; then
    . "$jobsv_sh"
    jobsv_or_exec "$0" "$@"
else
    jobsv_bg() { "$@" </dev/null; }
    fi

fatal() { rc="$1"; shift; printf %s\\n "${0##*/} error: $*" >&2 || true; exit "$rc"; }

blanks=false
comments=false
no_strip=false
handle_option() {
    case "$1" in
        a|all)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            blanks=true
            comments=true
            no_strip=true
            ;;
        b|blanks)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            blanks=true
            ;;
        c|comments)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            comments=true
            ;;
        no-strip)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            no_strip=true
            ;;

        no-blanks)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            blanks=false
            ;;
        no-comments)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            comments=false
            ;;
        strip)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            no_strip=false
            ;;
        *) fatal 64 "unknown option $1" ;;
        esac
    }
while [ $# -gt 0 ]; do
    case "$1" in
        --) shift; break ;;
        --*=*) x="${1#--}"; handle_option "${x%%=*}" "${x#*=}"; shift ;;
        --*) handle_option "${1#--}"; shift ;;
        -?) handle_option "${1#-}"; shift ;;
        -?*)
            v="${1#??}"
            x="${1%"$v"}"
            handle_option "${x#-}" "$v"
            shift
            ;;
        *) break ;;
        esac
    done

[ $# != 0 ] || fatal 64 'missing CMD argument'
which -- "$1" >/dev/null 2>&1 || fatal 65 "command not found: $1"

if $comments; then
    keep_if_comment() { true; }
else
    if $no_strip; then
        keep_if_comment() {
            set -- "$(printf %s "$1" | sed 's/^  *//')"
            case "$1" in '#'*) return 1 ;; esac
            }
    else
        keep_if_comment() {
            case "$1" in '#'*) return 1 ;; esac
            }
        fi
    fi

JOBNO=1
export JOBNO
LINENO=0
export LINENO
export ORIG_LINE
while IFS= read -r ORIG_LINE; do
    LINENO=$((LINENO + 1))
    line="$ORIG_LINE"
    $no_strip || line="$(printf %s "$line" | sed -r 's/^ +| +$//g')"
    $blanks || [ -n "$line" ] || continue
    keep_if_comment "$line" || continue

    jobsv_bg "$@" "$line"
    JOBNO=$((JOBNO + 1))
    done
