#!/bin/sh -ue
#.help
# % init CMD..
# % started
# % release CMD.. &
# % acquire
# % sleeping
#
# Subcommands:
#   init CMD..
#     Initialize a new pool and run CMD.
#         --new                 don't reuse existing pool
#         --slots=N             start with N slots
#         --no-float            don't monitor pool to add slots
#         --debug               show debug details
#   started
#     Exit 0 if started, 69 if not started, or other for error.
#         --debug               show debug details
#   release CMD.. &
#     Pass active slot to CMD and then release slot when done.
#         --keep-stdin          stdin has been redirected for CMD
#   acquire
#     After passing slot to background task, acquire another to start work.
#   sleep-start
#     Release active slot; must use sleep-end when ready to start work.
#   sleep-end
#     Re-acquire active slot after sleep-start.
#
# Example:
#   #!/bin/sh -ue
#   # first way:
#   printf %s\\n "$@" | xlines -a du -s
#   # (if args do not contain newline)
#   # see doc/xlines
#   #
#   # second way:
#   which jobserver >/dev/null || exit 69
#   jobserver started || exec jobserver init "$0" "$@"
#   bg_job() { jobserver release "$@" & jobserver acquire; }
#   for x; do
#       bg_job du -s "$x"
#   done
#   wait

fatal() { rc="$1"; shift; printf %s\\n "${0##*/} error: $*" >&2; exit "$rc"; }

handle_option() { fatal 64 "unknown option $1"; }
while [ $# -gt 0 ]; do
    case "$1" in
        --) shift; break ;;
        --*=*) x="${1#--}"; handle_option "${x%%=*}" "${x#*=}"; shift ;;
        --*) handle_option "${1#--}"; shift ;;
        -?) handle_option "${1#-}"; shift ;;
        -?*)
            v="${1#??}"
            x="${1%"$v"}"
            handle_option "${x#-}" "$v"
            shift
            ;;
        *) break ;;
        esac
    done


if [ $# = 0 ]; then
    fatal 64 'missing sub-command'
    fi
sub="$(readlink -f "$0")-$1"
[ -e "$sub" ] || fatal 64 "unknown sub-command: $1"
shift
exec "$sub" "$@"
